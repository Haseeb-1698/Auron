import { Scan, ScanStatus, ScanType, ScanResult, Vulnerability } from '@models/Scan';
import { LabInstance, LabInstanceStatus } from '@models/LabInstance';
import { logger } from '@utils/logger';
import axios from 'axios';

/**
 * VulnerabilityScanService
 * Handles automated vulnerability scanning of lab instances
 *
 * Supports multiple scan types:
 * - Quick scans: Basic security checks
 * - Full scans: Comprehensive vulnerability assessment
 * - Custom scans: User-defined scan configurations
 */
export class VulnerabilityScanService {
  /**
   * Initiate a new vulnerability scan
   */
  static async startScan(
    userId: string,
    labId: string,
    instanceId: string,
    scanType: ScanType = ScanType.QUICK
  ): Promise<Scan> {
    try {
      // Verify instance exists and is running
      const instance = await LabInstance.findByPk(instanceId);
      if (!instance) {
        throw new Error('Lab instance not found');
      }

      if (instance.status !== LabInstanceStatus.RUNNING) {
        throw new Error('Lab instance must be running to scan');
      }

      // Create scan record
      const scan = await Scan.create({
        userId,
        labId,
        instanceId,
        scanType,
        status: ScanStatus.PENDING,
        targetUrl: instance.accessUrl,
        progress: 0,
        configuration: this.getDefaultConfiguration(scanType),
      });

      // Start scan in background
      this.executeScan(scan.id).catch((error) => {
        logger.error('Background scan failed:', error);
      });

      return scan;
    } catch (error) {
      logger.error('Failed to start scan:', error);
      throw error;
    }
  }

  /**
   * Execute the actual vulnerability scan
   * Can be called from API or background job
   */
  public static async executeScan(scanId: string): Promise<void> {
    const scan = await Scan.findByPk(scanId);
    if (!scan) {
      throw new Error('Scan not found');
    }

    try {
      // Update status to running
      await scan.update({
        status: ScanStatus.RUNNING,
        startedAt: new Date(),
        progress: 10,
      });

      logger.info(`Starting scan ${scanId} for target: ${scan.targetUrl}`);

      let results: ScanResult;

      // Execute scan based on type
      switch (scan.scanType) {
        case ScanType.QUICK:
          results = await this.executeQuickScan(scan);
          break;
        case ScanType.FULL:
          results = await this.executeFullScan(scan);
          break;
        case ScanType.CUSTOM:
          results = await this.executeCustomScan(scan);
          break;
        default:
          throw new Error(`Unknown scan type: ${scan.scanType}`);
      }

      // Update scan with results
      await scan.update({
        status: ScanStatus.COMPLETED,
        progress: 100,
        results,
        completedAt: new Date(),
      });

      logger.info(`Scan ${scanId} completed successfully`);
    } catch (error) {
      logger.error(`Scan ${scanId} failed:`, error);
      await scan.update({
        status: ScanStatus.FAILED,
        errorMessage: error instanceof Error ? error.message : 'Unknown error',
        completedAt: new Date(),
      });
      throw error;
    }
  }

  /**
   * Execute a quick scan (basic security checks)
   */
  private static async executeQuickScan(scan: Scan): Promise<ScanResult> {
    const vulnerabilities: Vulnerability[] = [];
    const startTime = Date.now();

    if (!scan.targetUrl) {
      throw new Error('No target URL specified for scan');
    }

    await scan.update({ progress: 20 });

    // 1. Check for common security headers
    const headerVulns = await this.checkSecurityHeaders(scan.targetUrl);
    vulnerabilities.push(...headerVulns);
    await scan.update({ progress: 40 });

    // 2. Check for common misconfigurations
    const configVulns = await this.checkMisconfigurations(scan.targetUrl);
    vulnerabilities.push(...configVulns);
    await scan.update({ progress: 60 });

    // 3. Check for exposed sensitive files
    const fileVulns = await this.checkExposedFiles(scan.targetUrl);
    vulnerabilities.push(...fileVulns);
    await scan.update({ progress: 80 });

    // 4. Basic port scan
    const portVulns = await this.checkOpenPorts(scan.targetUrl);
    vulnerabilities.push(...portVulns);
    await scan.update({ progress: 90 });

    const duration = Date.now() - startTime;

    return this.compileScanResults(vulnerabilities, duration);
  }

  /**
   * Execute a full comprehensive scan using OWASP ZAP
   */
  private static async executeFullScan(scan: Scan): Promise<ScanResult> {
    const vulnerabilities: Vulnerability[] = [];
    const startTime = Date.now();

    if (!scan.targetUrl) {
      throw new Error('No target URL specified for scan');
    }

    try {
      // Execute quick scan checks first
      await scan.update({ progress: 10 });
      const quickResults = await this.executeQuickScan(scan);
      vulnerabilities.push(...quickResults.vulnerabilities);

      await scan.update({ progress: 30 });

      // Execute OWASP ZAP spider and active scan
      const zapVulns = await this.executeZapScan(scan.targetUrl, scan);
      vulnerabilities.push(...zapVulns);

      await scan.update({ progress: 90 });

      const duration = Date.now() - startTime;
      return this.compileScanResults(vulnerabilities, duration);
    } catch (error) {
      logger.error('Full scan failed:', error);
      // Fall back to quick scan results if ZAP fails
      const duration = Date.now() - startTime;
      return this.compileScanResults(vulnerabilities, duration);
    }
  }

  /**
   * Execute custom scan with user-defined configuration
   */
  private static async executeCustomScan(scan: Scan): Promise<ScanResult> {
    // Use quick scan as fallback for custom scans
    return this.executeQuickScan(scan);
  }

  /**
   * Check for missing or misconfigured security headers
   */
  private static async checkSecurityHeaders(targetUrl: string): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    try {
      const response = await axios.get(targetUrl, {
        timeout: 10000,
        validateStatus: () => true,
      });

      const headers = response.headers;
      const securityHeaders = [
        { name: 'X-Frame-Options', severity: 'medium' as const },
        { name: 'X-Content-Type-Options', severity: 'low' as const },
        { name: 'Content-Security-Policy', severity: 'high' as const },
        { name: 'Strict-Transport-Security', severity: 'high' as const },
        { name: 'X-XSS-Protection', severity: 'medium' as const },
      ];

      for (const header of securityHeaders) {
        if (!headers[header.name.toLowerCase()]) {
          vulnerabilities.push({
            id: `missing-header-${header.name}`,
            name: `Missing Security Header: ${header.name}`,
            severity: header.severity,
            description: `The ${header.name} header is not set, which may expose the application to security risks.`,
            solution: `Configure the web server to send the ${header.name} header with appropriate values.`,
            references: [
              'https://owasp.org/www-project-secure-headers/',
              `https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/${header.name}`,
            ],
          });
        }
      }
    } catch (error) {
      logger.warn('Failed to check security headers:', error);
    }

    return vulnerabilities;
  }

  /**
   * Check for common misconfigurations
   */
  private static async checkMisconfigurations(targetUrl: string): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    try {
      // Check for directory listing
      const testPaths = ['/assets/', '/uploads/', '/files/', '/images/'];
      for (const path of testPaths) {
        try {
          const response = await axios.get(`${targetUrl}${path}`, {
            timeout: 5000,
            validateStatus: () => true,
          });

          if (response.status === 200 && response.data.includes('Index of')) {
            vulnerabilities.push({
              id: `directory-listing-${path}`,
              name: 'Directory Listing Enabled',
              severity: 'medium',
              description: `Directory listing is enabled for ${path}, exposing file structure.`,
              location: path,
              solution: 'Disable directory listing in web server configuration.',
              references: ['https://owasp.org/www-project-web-security-testing-guide/'],
            });
          }
        } catch {
          // Ignore connection errors for individual paths
        }
      }
    } catch (error) {
      logger.warn('Failed to check misconfigurations:', error);
    }

    return vulnerabilities;
  }

  /**
   * Check for exposed sensitive files
   */
  private static async checkExposedFiles(targetUrl: string): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    const sensitiveFiles = [
      { path: '/.env', name: 'Environment File' },
      { path: '/.git/config', name: 'Git Configuration' },
      { path: '/config.php', name: 'PHP Configuration' },
      { path: '/web.config', name: 'Web Configuration' },
      { path: '/phpinfo.php', name: 'PHP Info Page' },
      { path: '/robots.txt', name: 'Robots.txt', severity: 'info' as const },
    ];

    for (const file of sensitiveFiles) {
      try {
        const response = await axios.get(`${targetUrl}${file.path}`, {
          timeout: 5000,
          validateStatus: () => true,
        });

        if (response.status === 200) {
          vulnerabilities.push({
            id: `exposed-file-${file.path}`,
            name: `Exposed Sensitive File: ${file.name}`,
            severity: file.severity || 'high',
            description: `The file ${file.path} is publicly accessible, potentially exposing sensitive information.`,
            location: file.path,
            solution: `Remove or restrict access to ${file.path}.`,
            references: ['https://owasp.org/www-project-top-ten/'],
          });
        }
      } catch {
        // Ignore connection errors
      }
    }

    return vulnerabilities;
  }

  /**
   * Check for open/suspicious ports
   */
  private static async checkOpenPorts(_targetUrl: string): Promise<Vulnerability[]> {
    // Port scanning would require additional tools/libraries
    // Return empty array for now
    return [];
  }

  /**
   * Compile scan results with summary statistics
   */
  private static compileScanResults(
    vulnerabilities: Vulnerability[],
    duration: number
  ): ScanResult {
    const summary = {
      total: vulnerabilities.length,
      critical: vulnerabilities.filter((v) => v.severity === 'critical').length,
      high: vulnerabilities.filter((v) => v.severity === 'high').length,
      medium: vulnerabilities.filter((v) => v.severity === 'medium').length,
      low: vulnerabilities.filter((v) => v.severity === 'low').length,
      info: vulnerabilities.filter((v) => v.severity === 'info').length,
    };

    return {
      vulnerabilities,
      summary,
      duration,
      timestamp: new Date().toISOString(),
    };
  }

  /**
   * Get scan by ID
   */
  static async getScanById(scanId: string): Promise<Scan | null> {
    return Scan.findByPk(scanId, {
      include: ['user', 'lab', 'instance'],
    });
  }

  /**
   * Get scans for a specific user
   */
  static async getUserScans(userId: string, limit = 20): Promise<Scan[]> {
    return Scan.findAll({
      where: { userId },
      order: [['createdAt', 'DESC']],
      limit,
      include: ['lab'],
    });
  }

  /**
   * Get scans for a specific lab
   */
  static async getLabScans(labId: string, limit = 20): Promise<Scan[]> {
    return Scan.findAll({
      where: { labId },
      order: [['createdAt', 'DESC']],
      limit,
      include: ['user'],
    });
  }

  /**
   * Cancel a running scan
   */
  static async cancelScan(scanId: string): Promise<Scan> {
    const scan = await Scan.findByPk(scanId);
    if (!scan) {
      throw new Error('Scan not found');
    }

    if (scan.status !== ScanStatus.RUNNING && scan.status !== ScanStatus.PENDING) {
      throw new Error('Can only cancel pending or running scans');
    }

    await scan.update({
      status: ScanStatus.CANCELLED,
      completedAt: new Date(),
    });

    return scan;
  }

  /**
   * Execute OWASP ZAP spider and active scan
   */
  private static async executeZapScan(targetUrl: string, scan: Scan): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];
    const zapApiUrl = process.env.ZAP_API_URL || 'http://zap:8090';
    const zapApiKey = process.env.ZAP_API_KEY || 'auron-zap-api-key';
    const timeout = parseInt(process.env.ZAP_SCAN_TIMEOUT || '300000', 10);

    try {
      logger.info(`Starting ZAP scan for ${targetUrl}`);

      // 1. Spider the target to discover URLs
      await scan.update({ progress: 35 });
      const spiderResponse = await axios.get(`${zapApiUrl}/JSON/spider/action/scan/`, {
        params: {
          apikey: zapApiKey,
          url: targetUrl,
          maxChildren: '10',
          recurse: 'true',
          contextName: '',
          subtreeOnly: 'false',
        },
        timeout: 30000,
      });

      const spiderScanId = spiderResponse.data?.scan;
      if (!spiderScanId) {
        logger.warn('ZAP spider did not return a scan ID');
        return vulnerabilities;
      }

      // Poll spider status until complete (max 2 minutes)
      const spiderStartTime = Date.now();
      const spiderMaxWait = 120000; // 2 minutes
      while (Date.now() - spiderStartTime < spiderMaxWait) {
        const statusResponse = await axios.get(`${zapApiUrl}/JSON/spider/view/status/`, {
          params: { apikey: zapApiKey, scanId: spiderScanId },
          timeout: 10000,
        });

        const progress = parseInt(statusResponse.data?.status || '0', 10);
        await scan.update({ progress: 35 + Math.floor(progress * 0.15) }); // 35-50%

        if (progress >= 100) {
          logger.info('ZAP spider completed');
          break;
        }

        await new Promise((resolve) => setTimeout(resolve, 2000)); // Wait 2s between polls
      }

      // 2. Run active scan
      await scan.update({ progress: 50 });
      const scanResponse = await axios.get(`${zapApiUrl}/JSON/ascan/action/scan/`, {
        params: {
          apikey: zapApiKey,
          url: targetUrl,
          recurse: 'true',
          inScopeOnly: 'false',
          scanPolicyName: '',
          method: '',
          postData: '',
        },
        timeout: 30000,
      });

      const activeScanId = scanResponse.data?.scan;
      if (!activeScanId) {
        logger.warn('ZAP active scan did not return a scan ID');
        return vulnerabilities;
      }

      // Poll active scan status (max timeout from env)
      const scanStartTime = Date.now();
      while (Date.now() - scanStartTime < timeout) {
        const statusResponse = await axios.get(`${zapApiUrl}/JSON/ascan/view/status/`, {
          params: { apikey: zapApiKey, scanId: activeScanId },
          timeout: 10000,
        });

        const progress = parseInt(statusResponse.data?.status || '0', 10);
        await scan.update({ progress: 50 + Math.floor(progress * 0.35) }); // 50-85%

        if (progress >= 100) {
          logger.info('ZAP active scan completed');
          break;
        }

        await new Promise((resolve) => setTimeout(resolve, 3000)); // Wait 3s between polls
      }

      // 3. Fetch alerts (vulnerabilities found)
      await scan.update({ progress: 85 });
      const alertsResponse = await axios.get(`${zapApiUrl}/JSON/core/view/alerts/`, {
        params: {
          apikey: zapApiKey,
          baseurl: targetUrl,
          start: '0',
          count: '1000',
        },
        timeout: 30000,
      });

      const alerts = alertsResponse.data?.alerts || [];
      logger.info(`ZAP found ${alerts.length} alerts`);

      // Parse ZAP alerts into our vulnerability format
      for (const alert of alerts) {
        vulnerabilities.push({
          id: `zap-${alert.pluginId}-${alert.id}`,
          name: alert.alert || 'Unknown Vulnerability',
          severity: this.mapZapRiskToSeverity(alert.risk),
          description: alert.description || alert.alert,
          location: alert.url || targetUrl,
          evidence: alert.evidence || alert.attack,
          solution: alert.solution || 'Review and remediate the vulnerability.',
          references: alert.reference ? alert.reference.split('\n').filter(Boolean) : [],
          cvssScore: alert.cweid ? undefined : undefined,
          cweId: alert.cweid || undefined,
        });
      }

      logger.info(`Processed ${vulnerabilities.length} ZAP vulnerabilities`);
    } catch (error) {
      logger.error('ZAP scan failed:', error);
      // Don't throw - let quick scan results be returned
    }

    return vulnerabilities;
  }

  /**
   * Map ZAP risk levels to our severity levels
   */
  private static mapZapRiskToSeverity(
    risk: string
  ): 'critical' | 'high' | 'medium' | 'low' | 'info' {
    const riskLower = (risk || '').toLowerCase();
    switch (riskLower) {
      case 'high':
        return 'high';
      case 'medium':
        return 'medium';
      case 'low':
        return 'low';
      case 'informational':
        return 'info';
      default:
        return 'medium';
    }
  }

  /**
   * Get default configuration for scan type
   */
  private static getDefaultConfiguration(scanType: ScanType): Record<string, unknown> {
    switch (scanType) {
      case ScanType.QUICK:
        return {
          timeout: 300000, // 5 minutes
          maxRequests: 100,
          followRedirects: true,
        };
      case ScanType.FULL:
        return {
          timeout: 1800000, // 30 minutes
          maxRequests: 1000,
          followRedirects: true,
          deepScan: true,
        };
      case ScanType.CUSTOM:
        return {};
      default:
        return {};
    }
  }
}

export default VulnerabilityScanService;
