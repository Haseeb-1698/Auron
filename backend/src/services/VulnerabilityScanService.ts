import { Scan, ScanStatus, ScanType, ScanResult, Vulnerability } from '@models/Scan';
import { LabInstance, LabInstanceStatus } from '@models/LabInstance';
import { logger } from '@utils/logger';
import axios from 'axios';

/**
 * VulnerabilityScanService
 * Handles automated vulnerability scanning of lab instances
 *
 * Supports multiple scan types:
 * - Quick scans: Basic security checks
 * - Full scans: Comprehensive vulnerability assessment
 * - Custom scans: User-defined scan configurations
 */
export class VulnerabilityScanService {
  /**
   * Initiate a new vulnerability scan
   */
  static async startScan(
    userId: string,
    labId: string,
    instanceId: string,
    scanType: ScanType = ScanType.QUICK
  ): Promise<Scan> {
    try {
      // Verify instance exists and is running
      const instance = await LabInstance.findByPk(instanceId);
      if (!instance) {
        throw new Error('Lab instance not found');
      }

      if (instance.status !== LabInstanceStatus.RUNNING) {
        throw new Error('Lab instance must be running to scan');
      }

      // Create scan record
      const scan = await Scan.create({
        userId,
        labId,
        instanceId,
        scanType,
        status: ScanStatus.PENDING,
        targetUrl: instance.accessUrl,
        progress: 0,
        configuration: this.getDefaultConfiguration(scanType),
      });

      // Start scan in background
      this.executeScan(scan.id).catch((error) => {
        logger.error('Background scan failed:', error);
      });

      return scan;
    } catch (error) {
      logger.error('Failed to start scan:', error);
      throw error;
    }
  }

  /**
   * Execute the actual vulnerability scan
   * Can be called from API or background job
   */
  public static async executeScan(scanId: string): Promise<void> {
    const scan = await Scan.findByPk(scanId);
    if (!scan) {
      throw new Error('Scan not found');
    }

    try {
      // Update status to running
      await scan.update({
        status: ScanStatus.RUNNING,
        startedAt: new Date(),
        progress: 10,
      });

      logger.info(`Starting scan ${scanId} for target: ${scan.targetUrl}`);

      let results: ScanResult;

      // Execute scan based on type
      switch (scan.scanType) {
        case ScanType.QUICK:
          results = await this.executeQuickScan(scan);
          break;
        case ScanType.FULL:
          results = await this.executeFullScan(scan);
          break;
        case ScanType.CUSTOM:
          results = await this.executeCustomScan(scan);
          break;
        default:
          throw new Error(`Unknown scan type: ${scan.scanType}`);
      }

      // Update scan with results
      await scan.update({
        status: ScanStatus.COMPLETED,
        progress: 100,
        results,
        completedAt: new Date(),
      });

      logger.info(`Scan ${scanId} completed successfully`);
    } catch (error) {
      logger.error(`Scan ${scanId} failed:`, error);
      await scan.update({
        status: ScanStatus.FAILED,
        errorMessage: error instanceof Error ? error.message : 'Unknown error',
        completedAt: new Date(),
      });
      throw error;
    }
  }

  /**
   * Execute a quick scan (basic security checks)
   */
  private static async executeQuickScan(scan: Scan): Promise<ScanResult> {
    const vulnerabilities: Vulnerability[] = [];
    const startTime = Date.now();

    if (!scan.targetUrl) {
      throw new Error('No target URL specified for scan');
    }

    await scan.update({ progress: 20 });

    // 1. Check for common security headers
    const headerVulns = await this.checkSecurityHeaders(scan.targetUrl);
    vulnerabilities.push(...headerVulns);
    await scan.update({ progress: 40 });

    // 2. Check for common misconfigurations
    const configVulns = await this.checkMisconfigurations(scan.targetUrl);
    vulnerabilities.push(...configVulns);
    await scan.update({ progress: 60 });

    // 3. Check for exposed sensitive files
    const fileVulns = await this.checkExposedFiles(scan.targetUrl);
    vulnerabilities.push(...fileVulns);
    await scan.update({ progress: 80 });

    // 4. Basic port scan
    const portVulns = await this.checkOpenPorts(scan.targetUrl);
    vulnerabilities.push(...portVulns);
    await scan.update({ progress: 90 });

    const duration = Date.now() - startTime;

    return this.compileScanResults(vulnerabilities, duration);
  }

  /**
   * Execute a full comprehensive scan
   */
  private static async executeFullScan(scan: Scan): Promise<ScanResult> {
    const vulnerabilities: Vulnerability[] = [];
    const startTime = Date.now();

    if (!scan.targetUrl) {
      throw new Error('No target URL specified for scan');
    }

    // Execute all quick scan checks
    await scan.update({ progress: 10 });
    const quickResults = await this.executeQuickScan(scan);
    vulnerabilities.push(...quickResults.vulnerabilities);

    await scan.update({ progress: 50 });

    // Additional comprehensive checks
    // TODO: Integrate with OWASP ZAP or Nuclei for deeper scanning
    // For now, return quick scan results
    const duration = Date.now() - startTime;

    return this.compileScanResults(vulnerabilities, duration);
  }

  /**
   * Execute custom scan with user-defined configuration
   */
  private static async executeCustomScan(scan: Scan): Promise<ScanResult> {
    // Use quick scan as fallback for custom scans
    return this.executeQuickScan(scan);
  }

  /**
   * Check for missing or misconfigured security headers
   */
  private static async checkSecurityHeaders(targetUrl: string): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    try {
      const response = await axios.get(targetUrl, {
        timeout: 10000,
        validateStatus: () => true,
      });

      const headers = response.headers;
      const securityHeaders = [
        { name: 'X-Frame-Options', severity: 'medium' as const },
        { name: 'X-Content-Type-Options', severity: 'low' as const },
        { name: 'Content-Security-Policy', severity: 'high' as const },
        { name: 'Strict-Transport-Security', severity: 'high' as const },
        { name: 'X-XSS-Protection', severity: 'medium' as const },
      ];

      for (const header of securityHeaders) {
        if (!headers[header.name.toLowerCase()]) {
          vulnerabilities.push({
            id: `missing-header-${header.name}`,
            name: `Missing Security Header: ${header.name}`,
            severity: header.severity,
            description: `The ${header.name} header is not set, which may expose the application to security risks.`,
            solution: `Configure the web server to send the ${header.name} header with appropriate values.`,
            references: [
              'https://owasp.org/www-project-secure-headers/',
              `https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/${header.name}`,
            ],
          });
        }
      }
    } catch (error) {
      logger.warn('Failed to check security headers:', error);
    }

    return vulnerabilities;
  }

  /**
   * Check for common misconfigurations
   */
  private static async checkMisconfigurations(targetUrl: string): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    try {
      // Check for directory listing
      const testPaths = ['/assets/', '/uploads/', '/files/', '/images/'];
      for (const path of testPaths) {
        try {
          const response = await axios.get(`${targetUrl}${path}`, {
            timeout: 5000,
            validateStatus: () => true,
          });

          if (response.status === 200 && response.data.includes('Index of')) {
            vulnerabilities.push({
              id: `directory-listing-${path}`,
              name: 'Directory Listing Enabled',
              severity: 'medium',
              description: `Directory listing is enabled for ${path}, exposing file structure.`,
              location: path,
              solution: 'Disable directory listing in web server configuration.',
              references: ['https://owasp.org/www-project-web-security-testing-guide/'],
            });
          }
        } catch {
          // Ignore connection errors for individual paths
        }
      }
    } catch (error) {
      logger.warn('Failed to check misconfigurations:', error);
    }

    return vulnerabilities;
  }

  /**
   * Check for exposed sensitive files
   */
  private static async checkExposedFiles(targetUrl: string): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    const sensitiveFiles = [
      { path: '/.env', name: 'Environment File' },
      { path: '/.git/config', name: 'Git Configuration' },
      { path: '/config.php', name: 'PHP Configuration' },
      { path: '/web.config', name: 'Web Configuration' },
      { path: '/phpinfo.php', name: 'PHP Info Page' },
      { path: '/robots.txt', name: 'Robots.txt', severity: 'info' as const },
    ];

    for (const file of sensitiveFiles) {
      try {
        const response = await axios.get(`${targetUrl}${file.path}`, {
          timeout: 5000,
          validateStatus: () => true,
        });

        if (response.status === 200) {
          vulnerabilities.push({
            id: `exposed-file-${file.path}`,
            name: `Exposed Sensitive File: ${file.name}`,
            severity: file.severity || 'high',
            description: `The file ${file.path} is publicly accessible, potentially exposing sensitive information.`,
            location: file.path,
            solution: `Remove or restrict access to ${file.path}.`,
            references: ['https://owasp.org/www-project-top-ten/'],
          });
        }
      } catch {
        // Ignore connection errors
      }
    }

    return vulnerabilities;
  }

  /**
   * Check for open/suspicious ports
   */
  private static async checkOpenPorts(_targetUrl: string): Promise<Vulnerability[]> {
    // Port scanning would require additional tools/libraries
    // Return empty array for now
    return [];
  }

  /**
   * Compile scan results with summary statistics
   */
  private static compileScanResults(
    vulnerabilities: Vulnerability[],
    duration: number
  ): ScanResult {
    const summary = {
      total: vulnerabilities.length,
      critical: vulnerabilities.filter((v) => v.severity === 'critical').length,
      high: vulnerabilities.filter((v) => v.severity === 'high').length,
      medium: vulnerabilities.filter((v) => v.severity === 'medium').length,
      low: vulnerabilities.filter((v) => v.severity === 'low').length,
      info: vulnerabilities.filter((v) => v.severity === 'info').length,
    };

    return {
      vulnerabilities,
      summary,
      duration,
      timestamp: new Date().toISOString(),
    };
  }

  /**
   * Get scan by ID
   */
  static async getScanById(scanId: string): Promise<Scan | null> {
    return Scan.findByPk(scanId, {
      include: ['user', 'lab', 'instance'],
    });
  }

  /**
   * Get scans for a specific user
   */
  static async getUserScans(userId: string, limit = 20): Promise<Scan[]> {
    return Scan.findAll({
      where: { userId },
      order: [['createdAt', 'DESC']],
      limit,
      include: ['lab'],
    });
  }

  /**
   * Get scans for a specific lab
   */
  static async getLabScans(labId: string, limit = 20): Promise<Scan[]> {
    return Scan.findAll({
      where: { labId },
      order: [['createdAt', 'DESC']],
      limit,
      include: ['user'],
    });
  }

  /**
   * Cancel a running scan
   */
  static async cancelScan(scanId: string): Promise<Scan> {
    const scan = await Scan.findByPk(scanId);
    if (!scan) {
      throw new Error('Scan not found');
    }

    if (scan.status !== ScanStatus.RUNNING && scan.status !== ScanStatus.PENDING) {
      throw new Error('Can only cancel pending or running scans');
    }

    await scan.update({
      status: ScanStatus.CANCELLED,
      completedAt: new Date(),
    });

    return scan;
  }

  /**
   * Get default configuration for scan type
   */
  private static getDefaultConfiguration(scanType: ScanType): Record<string, unknown> {
    switch (scanType) {
      case ScanType.QUICK:
        return {
          timeout: 300000, // 5 minutes
          maxRequests: 100,
          followRedirects: true,
        };
      case ScanType.FULL:
        return {
          timeout: 1800000, // 30 minutes
          maxRequests: 1000,
          followRedirects: true,
          deepScan: true,
        };
      case ScanType.CUSTOM:
        return {};
      default:
        return {};
    }
  }
}

export default VulnerabilityScanService;
